name: Reverse Engineering
description: ""

resources:
  - type: header
    content: Reverse Engineering Resources
  - name: "Reverse Engineering: Introduction"
    type: lecture
    video: ClVocVk1c5g
    playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
    slides: 1hw_STBTJh4xqMv4TZAPRqt2rYIEAXXaCQlaBetxUufU
  - name: "Reverse Engineering: Functions and Frames"
    type: lecture
    video: 3IdeyjrMBA4
    playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
    slides: 125gIw6rNKvwa-1DO6j3HTWbWtr2q3xD2coTCb0CgmAw
  - name: "Reverse Engineering: Data Access"
    type: lecture
    video: AtVprTb5xBs
    playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
    slides: 154CQfQtpleaAQv9xNI1FVosbXc_18VZvXVpcs9Ljzzo
  - name: "Reverse Engineering: Static Tools"
    type: lecture
    video: ls4Eoew6aSY
    playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
    slides: 1GcRLX3-cD9eLweEixmBPfawY7viOQWApG7E_HFfqHQQ
  - name: "Reverse Engineering: Dynamic Tools"
    type: lecture
    video: HcBordv7aWU
    playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
    slides: 13yzjaRTIlloV8Lg5fcQN2ZYXooVqizLgHVby1ltYeWY
  - name: "Reverse Engineering: Real-world Applications"
    type: lecture
    video: 2pqvHSy11JE
    playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
    slides: 1HWiy6OzvPO8YhgTPOsALobh9LagZsJ3Jsx7DJFLAKn4
  - name: Other Resources
    type: markdown
    content: |
      There are many resources related to reverse engineering around the internet.

      - A good place to start is a series of walkthroughs of several hacking challenges by ASU's own Adam Doupe on his [YouTube channel](https://www.youtube.com/watch?v=qGt-0OOAFcM&list=PLK06XT3hFPziMAZj8QuoqC8iVaEbrlZWh).
      - A comprehensive revese engineering [tutorial series](https://github.com/mytechnotalent/Reverse-Engineering).
  - name: Useful Tools
    type: markdown
    content: |
      As mentioned in the slides, there are a number of useful tools for this assignment!
      Here is a (non-exhaustive) list:

      * `gdb` will let you run and inspect the state of these programs.
        Please check out the Debugging Refresher module.
        We have also provided a quick briefer here.
        Some useful gdb concepts:
         * Know the difference between `step instruction` (`si`) and `next instruction` (`ni`).
           It boils down to the fact that `si` will follow jumps, and `ni` will step over jumps.
           This means that if you use `si`, you will quickly find yourself crawling through libc code, which is insane and unnecessary.
         * You can use `x/i $rip` to disassemble the next instruction that will be executed.
           You can call `display/i $rip` to make the next instruction display every time gdb prompts you for input.
           You can also do `x/2i` and `display/2i` to print two (or other quantities of) instructions.
         * The `disas` command will disassemble the current function that you are looking at.
         * gdb can be scripted!
           Look up conditional breakpoints and scriptable breakpoints in the gdb manual.
         * Modern binaries are _position independent_, meaning that they can be loaded anywhere in memory when they run.
           GDB will load them at the offset `0x555555554000`.
           This means that if objdump is telling you that main starts at some address like, `0x100`, the address when debugging with GDB will be `0x555555554100`
      * `strings` will list printable strings in the file.
        This is useful for looking for constant strings that the program checks for (such as file names and so on) in the course of getting input.
        Keep in mind that the options for string include a minimum size that it will print.
      * Don't forget about pwntools! You will need to interact heavily with these programs. Do it right (with pwntools).
      * `rappel` is a nice tool to help you figure out what certain instructions do.
      * Tools for reverse engineering actual binaries:
         * IDA, accessible via the Desktop in the dojo, is the industry standard of reverse-engineering tools.
         * Ghidra, also accessible via the Desktop in the dojo, is an open source direct competitor to IDA that is used and loved by many.
         * angr-management, also accessible via the Desktop in the dojo, is an open source up-and-coming reversing tool with some advanced functionality.
         * [Binary Ninja Cloud](https://cloud.binary.ninja), accessible separately through your web browser, is a free binary reverse engineering tool.
         * In a pinch, `objdump -d -M intel the_binary` will disassemble the binary you want to look at.
           `-M intel`, in that command, makes objdump give you nice and readable Intel assembly syntax.


  - type: header
    content: Crackmes
  - type: markdown
    name: Crackmes
    content: |
      The classic reverse engineering challenge is a "crackme", where you are given a binary that will check whether or not you have provided the correct license key.  
    expandable: false
  - id: level-1-0
    name: Terrible Token (Easy)
    description: Reverse engineer this challenge to find the correct license key.
    type: challenge
  - id: level-1-1
    name: Terrible Token (Hard)
    description: Reverse engineer this challenge to find the correct license key.
    type: challenge
  - id: level-2-0
    name: Tangled Ticket (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-2-1
    name: Tangled Ticket (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-3-0 # No
    name: Twisted Text (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-3-1 # No
    name: Twisted Text (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-4-0 # No
    name: Tidy Task (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-4-1 # No 
    name: Tidy Task (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-5-0 # No
    name: Logical License (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-5-1 # No
    name: Logical License (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: bit-bender
    name: Bit Bender
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: substitution-sorcery
    name: Substitution Sorcery
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-6-0
    name: Meager Mangler (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-6-1
    name: Meager Mangler (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-7-0 # No
    name: Modest Mangler (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
      before being compared to the correct key.
    type: challenge
  - id: level-7-1 # No
    name: Modest Mangler (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key.
    type: challenge
  - id: level-8-0
    name: Monstrous Mangler (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key.
    type: challenge
  - id: level-8-1
    name: Monstrous Mangler (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key.
    type: challenge

  - type: header
    content: Patching
  - type: markdown
    name: Patching
    content: |
      When working with a binaries, sometimes you may want to change the behavior of the binary itself.  This can be accomplished by patching the binary.  Patching is the process of changing the assembly instructions in the binary to change its behavior.  The following set of challenges will allow you to patch a limited number of bytes in the binary at runtime to change its behavior.
    expandable: false
  - id: level-9-0
    name: Patched Up (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key. This challenge allows you to patch 5 bytes in the binary.
    type: challenge
  - id: level-9-1
    name: Patched Up (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key. This challenge allows you to patch 5 bytes in the binary.
    type: challenge
  - id: level-10-0
    name: Puzzle Patch (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key. This challenge allows you to patch 1 byte in the binary.
    type: challenge
  - id: level-10-1
    name: Puzzle Patch (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key. This challenge allows you to patch 1 byte in the binary.
    type: challenge
  - id: level-11-0
    name: Patch Perfect (Easy)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key. This challenge allows you to patch 2 bytes in the binary, but performs an integrity check afterwards.
    type: challenge
  - id: level-11-1
    name: Patch Perfect (Hard)
    description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow before being compared to the correct key. This challenge allows you to patch 2 bytes in the binary, but performs an integrity check afterwards.
    type: challenge

  - type: header
    content: Yan85
  - type: markdown
    name: Yan85
    content: |
      Yan85 is a virtual machine and obfuscation engine.  It is designed to be a simple, yet powerful, virtual machine that can be used to obfuscate code.  The following set of challenges leverage the Yan85 virtual machine.  Early time spent understanding how this virtual machine works will pay off in future challenges that use Yan85.
    expandable: false
  - id: level-12-0 # No
    name: This is Yancode (Easy)
    description: |-
      We're about to dive into reverse engineering obfuscated code!
      To better prepare you for the journey ahead, this challenge is a very straightforward crackme, but using slightly different code, memory layout, and input format.
      We will progressively obfuscate this in future levels, but this level should be a freebie!
    type: challenge
  - id: level-12-1 # No
    name: This is Yancode (Hard)
    description: |-
      We're about to dive into reverse engineering obfuscated code!
      To better prepare you for the journey ahead, this challenge is a very straightforward crackme, but using slightly different code, memory layout, and input format.
      We will progressively obfuscate this in future levels, but this level should be a freebie!
    type: challenge
  - id: level-13-0 # No
    name: Powered by Yancode (Easy)
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
    type: challenge
  - id: level-13-1 # No
    name: Powered by Yancode (Hard)
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
    type: challenge
  - id: level-14-0 # No
    name: Yancode Inside (Easy)
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
    type: challenge
  - id: level-14-1 # No
    name: Yancode Inside (Hard)
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
    type: challenge
  - id: level-15-0
    name: Trust the Yancode (Easy)
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
    type: challenge
  - id: level-15-1
    name: Trust the Yancode (Hard)
    description: |-
      Let's dive into reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      If you are clever, you won't need to reverse _too_ much VM code.
    type: challenge
  - id: level-16-0
    name: Know the Yancode (Easy)
    description: |-
      Let's continue deeper in reverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    type: challenge
  - id: level-16-1
    name: Know the Yancode (Hard)
    description: |-
      Let's continue deeper inreverse engineering obfuscated code!
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    type: challenge
  - id: level-17-0
    name: Master the Yancode (Easy)
    description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
      \ how to get the flag!"
    type: challenge
  - id: level-17-1
    name: Master the Yancode (Hard)
    description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
      \ how to get the flag!"
    type: challenge
  - id: level-18-0
    name: Transcend the Yancode (Easy)
    description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
      \ how to get the flag!"
    type: challenge
  - id: level-18-1
    name: Transcend the Yancode (Hard)
    description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
      \ how to get the flag!"
    type: challenge
  - id: level-19-0
    name: The Yanalyzer (Easy)
    description: |-
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      This is a full end-to-end obfuscated challenge, like you might see in real-world obfuscated code!
    type: challenge
  - id: level-19-1
    name: The Yanalyzer (Hard)
    description: |-
      This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
      This is a full end-to-end obfuscated challenge, like you might see in real-world obfuscated code!
    type: challenge
  - id: level-20-0
    name: The Yangler (Easy)
    description: 'Reverse engineer this custom emulator and architecture to understand how to get the flag! '
    type: challenge
  - id: level-20-1
    name: The Yangler (Hard)
    description: 'Reverse engineer this custom emulator and architecture to understand how to get the flag! '
    type: challenge
  - id: level-21-0
    name: Yancraft (Easy)
    description: Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag.
    type: challenge
  - id: level-21-1
    name: Yancraft (Hard)
    description: Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag.
    type: challenge
  - id: level-22-0
    name: Yansanity (Easy)
    description: |-
      Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag, with a twist.
      This is the final boss.
      Are you a true Yan-head?
    type: challenge
  - id: level-22-1
    name: Yansanity (Hard)
    description: |-
      Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag, with a twist.
      This is the final boss.
      Are you a true Yan-head?
    type: challenge

  - type: header
    content: Cows and Bulls
  - type: markdown
    name: Cows and Bulls
    content: |
      [Cows and Bulls](https://en.wikipedia.org/wiki/Bulls_and_cows) is a classic code-breaking game where the objective is to correctly guess a random number.  This set of challenges will require you to reverse engineer a binary that plays this guessing game with you.  Be warned, winning the game (and in turn, getting the flag) may not be as easy as it seems!
    expandable: false
  - id: when-the-cow-says-moo
    name: When the Cow Says Moo
    description: |-
      Reverse engineer the binary to find out how to win this game of Cows and Bulls!
    type: challenge
  - id: predictable-migration
    name: Predictable Migration
    description: |-
      Reverse engineer the binary to find out how to win this game of Cows and Bulls!
    type: challenge
  - id: hashing-heifers
    name: Hashing Heifers
    description: |-
      Reverse engineer the binary to find out how to win this game of Cows and Bulls!
    type: challenge
  - id: salty-stampede
    name: Salty Stampede
    description: |-
      Reverse engineer the binary to find out how to win this game of Cows and Bulls!
    type: challenge
